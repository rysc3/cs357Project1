diff --git a/Anagrams.cabal b/Anagrams.cabal
index f65be93..261024f 100644
--- a/Anagrams.cabal
+++ b/Anagrams.cabal
@@ -1,6 +1,25 @@
 cabal-version:      3.0
+-- The cabal-version field refers to the version of the .cabal specification,
+-- and can be different from the cabal-install (the tool) version and the
+-- Cabal (the library) version you are using. As such, the Cabal (the library)
+-- version used must be equal or greater than the version stated in this field.
+-- Starting from the specification version 2.2, the cabal-version field must be
+-- the first thing in the cabal file.
 
+-- Initial package description 'Anagrams' generated by
+-- 'cabal init'. For further documentation, see:
+--   http://haskell.org/cabal/users-guide/
+--
+-- The name of the package.
 name:               Anagrams
+
+-- The package version.
+-- See the Haskell package versioning policy (PVP) for standards
+-- guiding when and how versions should be incremented.
+-- https://pvp.haskell.org
+-- PVP summary:     +-+------- breaking API changes
+--                  | | +----- non-breaking API additions
+--                  | | | +--- code changes with no API change
 version:            0.1.0.0
 
 -- A short (one-line) description of the package.
@@ -10,35 +29,52 @@ version:            0.1.0.0
 -- description:
 
 -- URL for the project homepage or repository.
-homepage:           https://github.com/rysc3/proj1
+homepage:           https://github.com/rysc3/cs357/blob/main/proj1
 
 -- The license under which the package is released.
 license:            MIT
+
+-- The file containing the license text.
 license-file:       LICENSE
-author:             Ryan Scherbarth
+
+-- The package author(s).
+author:             Maisy Dunlavy
+
+-- An email address to which users can send suggestions, bug reports, and patches.
 maintainer:         rscherbarth@unm.edu
+
+-- A copyright notice.
+-- copyright:
 build-type:         Simple
+
+-- Extra doc files to be distributed with the package, such as a CHANGELOG or a README.
 extra-doc-files:    CHANGELOG.md
 
+-- Extra source files to be distributed with the package, such as examples, or a tutorial module.
+-- extra-source-files:
+
 common warnings
-  ghc-options: -Wall -threaded
+    ghc-options: -Wall -threaded
 
--- Dependencies
 executable Anagrams
+    -- Import common warning flags.
+    import:           warnings
+
+    -- .hs or .lhs file containing the Main module.
     main-is:          Main.hs
 
-    other-modules:    Score, Dictionary, Tests
+    -- Modules included in this executable, other than Main.
+    other-modules: Score, Dictionary, Tests
+
+    -- LANGUAGE extensions used by modules in this package.
+    -- other-extensions:
 
-    build-depends:    base ^>=4.17.2.1 && < 5, 
-                      containers, 
-                      text, 
-                      brick >= 0.50, 
-                      vty, 
-                      vty-crossplatform, 
-                      optparse-applicative, 
-                      random,
+    -- Other library packages from which modules are imported.
+    build-depends:    base ^>=4.17.2.1, containers, text, brick, vty, vty-crossplatform,random,
                       time
 
+    -- Directories containing source files.
     hs-source-dirs:   app
 
-    default-language: Haskell2010
\ No newline at end of file
+    -- Base language which the package is written in.
+    default-language: Haskell2010
diff --git a/Dictionaries/Leaderboard.csv b/Dictionaries/Leaderboard.csv
deleted file mode 100644
index d3b8ebb..0000000
--- a/Dictionaries/Leaderboard.csv
+++ /dev/null
@@ -1,12 +0,0 @@
-10000, 4/10, Ryan 
-9999,  4/01, Ryan
-211633, 05/01, ryan
-420, 05/01, s
-1590000, 05/01, best
-494, 05/01, another
-468, 05/01, asdf
-8274, 5/24, myScore
-1221, 5/5, dan
-123099, 9/1, bobby
-098, 10,28, nick11337, 05/01, imthebestthereeverwas
-10553, 05/01, imthebest
diff --git a/README.md b/README.md
index ed91ece..c8be181 100644
--- a/README.md
+++ b/README.md
@@ -1,108 +1,22 @@
 # Project 1 - Anograms
 ## Ryan Scherbarth, Maisy Dunlavy, Molly Palko
 
-## Overview
-Upon starting the game, you'll be greeted with a few options:
+## GUI Library
+- brick 
 
-### Playing the game
+## Current plan 
+-- Anagrams game, using a generated sequence of characters the user will interact through brick to unscrammble the letters into as many words as possible
+--logic for making sure all the letters the user enters are part of the anagram thing
 
-      ------------------
-      Select an option:
-      1 - Play
-      2 - Leaderboard
-      3 - Settings
-      4 - Back/Quit
+-- we can try to use a dictionary to confirm that the words the user is inputing are actual words and not just garbage
 
-      ---
+--search algorithm to check whether the word they entered works
 
-If you select Play, you'll be prompted to choose the number of letters you'd like to use, and then the game will begin:
+-- sets of unscrammbled letters will not be random, we can have a few sets that we alternate that have a lot of words that can be generated
+--do we want a timer? a way to keep score? 
 
-      Starting the game...
-      How many letters would you like to play with?
 
-      ---
-      5
-      ---
-      Randomly selected letters: "TBPJL"
-      a   
-      -----------------------
-      T      B      P      J      L      => 1
-      b
-      a.........     1
-      -----------------------
-      T      B      P      J      L      => 3
-      c
-      a.........     1
-      b.........     2
-      -----------------------
-      T      B      P      J      L      => 6
-      d
-      a.........     1
-      b.........     2
-      c.........     3
-      -----------------------
-      T      B      P      J      L      => 10
+-- can brick do all the event handling and graphics that we need for anagrams? or will we need to use both? 
+from the program we have, how to we start implementing a user interface
 
-Once you've completed the game, you'll be prompted for a name, after which your score, name, and today's date will be recorded onto the leaderboard. You'll then be brought back to the main screen.
 
-
-### Leaderboard 
-There is also a leaderboard, stored internally at `Dictionaries/Leaderbaord.csv`. You can access it by entering `2` from the start menu.
-This will show you the top 10 scores, in sorted order, with the corresponding dates and usernames 
-
-      ------------------
-      Select an option:
-      1 - Play
-      2 - Leaderboard
-      3 - Settings
-      4 - Back/Quit
-
-      ---
-      2
-      ---
-      Showing the leaderboard...
-      1590000,  05/01,  best
-      211633,  05/01,  ryan
-      123099,  9/1,  bobby
-      10553,  05/01,  imthebest
-      10000,  4/10,  Ryan 
-      9999,   4/01,  Ryan
-      8274,  5/24,  myScore
-      1221,  5/5,  dan
-      494,  05/01,  another
-      468,  05/01,  asdf
-
-
-### Settings
-# TODO 
-The settings allow you to change game rules. You can select different point schemes or languages. You can also change the timelimit here. 
-
-It is not functional yet.
-
-      ------------------
-      Select an option:
-      1 - Play
-      2 - Leaderboard
-      3 - Settings
-      4 - Back/Quit
-
-      ---
-      3
-      ---
-      At some point, I'll put some settings here
-      1 - Back
-
-
-
-## Install
-### Dependencies 
-- Cabal 3.0
-- GHCI 9.4.8
-- brick >= 0.50.0
-
-### Download & run
-`git clone https://github.com/rysc3/proj1`
-
-`cd proj1`
-
-`cabal run`
\ No newline at end of file
diff --git a/app/Dictionary.hs b/app/Dictionary.hs
index 92443bc..4925ea4 100644
--- a/app/Dictionary.hs
+++ b/app/Dictionary.hs
@@ -6,47 +6,44 @@ module Dictionary(
 ) where
 
 import qualified Data.Map.Strict as M --need a map because we don't know how many children each node is going to have
-import Data.Text (pack, splitOn, unpack, toUpper)
+import Data.Text (pack, unpack, splitOn)
 import qualified Data.Text.IO as TIO
 import qualified Data.Text as T
 
-data Trie = Node
-  { endOfWord :: Bool,
-    children :: M.Map Char Trie
-  }
-  deriving (Eq)
-
--- Make tree show pretty
-instance Show Trie where
-  show trie = unlines $ map (showPath "") (M.toList (children trie))
-    where
-      showPath prefix (char, child) =
-        let newPath = prefix ++ [char]
-            indentation = if null prefix then "" else "    "
-            endMarker = if endOfWord child then " -> (END)" else ""
-        in indentation ++ newPath ++ endMarker ++ "\n" ++ showPath' newPath child
-      showPath' prefix (Node _ children') = unlines $ map (showPath prefix) (M.toList children')
+-- maisy was here
 
-emptyTrie :: Trie
-emptyTrie = Node False M.empty
+data Trie = Node {
+  endOfWord :: Bool,
+  children :: M.Map Char Trie
+}
+  deriving (Eq, Show)
 
 {-
-  TODO @here 
-  We need to convert every letter to be CAPITALIZED as we add it to the tree. Right now contains is case sensitive and returns false for a word if it has any capitalizations. 
-    
-    In the scoring data I have everything working by converting to be capitalized firsrt, so we should do the same thing here to keep it all uniform.
+  Input from the dictionary file is of the type:
+  ghci> take 75 contents
+"aa\r\naah\r\naahed\r\naahing\r\naahs\r\naal\r\naalii\r\naaliis..."
+
+  Map across all of the input string, and split every time we have a newline, in this case, `\r\n`
+
+  Import Data.Text to help here
+  pack to convet string to Text 
+  splitOn to split into a list of strings 
+  map unpack over list to convert back to strings
 -}
+emptyTrie :: Trie
+emptyTrie = Node False M.empty
+
 insert :: String -> Trie -> Trie
-insert [] trie = trie {endOfWord = True}
-insert (x : xs) trie =
-  let childNode = M.lookup x (children trie)
-      newNode = insert xs (maybe emptyTrie id childNode)
-      updatedChildren = M.insert x newNode (children trie)
-   in trie {children = updatedChildren}
+insert []     trie = trie { endOfWord = True }
+insert (x:xs) trie =
+    let childNode = M.lookup x (children trie)
+        newNode = insert xs (maybe emptyTrie id childNode)
+        updatedChildren = M.insert x newNode (children trie)
+    in trie { children = updatedChildren }
 
 contains :: String -> Trie -> Bool
 contains [] trie = endOfWord trie
-contains (x : xs) trie = maybe False (contains xs) (M.lookup x (children trie))
+contains (x:xs) trie = maybe False (contains xs) (M.lookup x (children trie)) --need to handle for nothing or Just cases when called 
 
 buildDictionary :: FilePath -> IO Trie
 buildDictionary filePath = do
@@ -60,4 +57,4 @@ getListOfStrings s = map T.unpack (T.splitOn charsToText s)
     charsToText = T.pack "\r\n"   -- these need to be Text
 
 readFileText :: FilePath -> IO T.Text
-readFileText filePath = TIO.readFile filePath
+readFileText filePath = TIO.readFile filePath
\ No newline at end of file
